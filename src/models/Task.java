package models;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import security.SecureCommunication;
import security.SecurityManager;

/**
 * Represents a computational task generated by an IoT device
 * that needs to be offloaded to edge or cloud resources
 */
public class Task {
    private String taskId;
    private int sourceDeviceId;
    private double cpuDemand;        // in Million Instructions (MI)
    private double networkDemand;    // in KB (data size to transfer)
    private double delaySensitivity; // between 0 and 1 (1 being most sensitive)
    private long creationTime;       // timestamp when task was created
    private long startTime;          // timestamp when task execution started
    private long completionTime;     // timestamp when task execution completed
    private String executionLocation; // LOCAL_EDGE, OTHER_EDGE, or CLOUD
    private TaskStatus status;
    
    // Security-related fields
    private String securityToken;
    private String integrityHash;
    private boolean isEncrypted;
    private Map<String, Object> securityMetadata;
    
    // Data generation and processing
    private Map<String, Object> generatedData;
    private boolean hasGeneratedData;
    
    public enum TaskStatus {
        CREATED,
        QUEUED,
        TRANSFERRING,
        EXECUTING,
        COMPLETED,
        FAILED
    }
    
    public Task(String taskId, int sourceDeviceId, double cpuDemand, 
                double networkDemand, double delaySensitivity, long creationTime) {
        this.taskId = taskId;
        this.sourceDeviceId = sourceDeviceId;
        this.cpuDemand = cpuDemand;
        this.networkDemand = networkDemand;
        this.delaySensitivity = delaySensitivity;
        this.creationTime = creationTime;
        this.status = TaskStatus.CREATED;
        
        // Initialize security fields
        this.securityToken = null;
        this.integrityHash = null;
        this.isEncrypted = false;
        this.securityMetadata = new HashMap<>();
        
        // Initialize data fields
        this.generatedData = new HashMap<>();
        this.hasGeneratedData = false;
    }
    
    /**
     * Create a secure task with authentication and integrity protection
     */
    public Task(String taskId, int sourceDeviceId, double cpuDemand, 
                double networkDemand, double delaySensitivity, long creationTime,
                SecurityManager securityManager) {
        this(taskId, sourceDeviceId, cpuDemand, networkDemand, delaySensitivity, creationTime);
        
        // Apply security measures
        this.securityToken = securityManager.generateToken(sourceDeviceId);
        this.integrityHash = SecureCommunication.generateHash(taskId + sourceDeviceId + cpuDemand + networkDemand);
        this.securityMetadata.put("tokenExpiry", System.currentTimeMillis() + 3600000); // 1 hour expiry
        this.securityMetadata.put("securityLevel", delaySensitivity > 0.7 ? "high" : "standard");
    }
    
    /**
     * Calculate the estimated execution time based on the available MIPS
     * @param mips Million Instructions Per Second of the executing resource
     * @return Estimated execution time in milliseconds
     */
    public double calculateExecutionTime(double mips) {
        return (cpuDemand / mips) * 1000; // Convert to milliseconds
    }
    
    /**
     * Calculate the estimated data transfer time based on available bandwidth
     * @param bandwidth Available bandwidth in Mbps
     * @return Estimated transfer time in milliseconds
     */
    public double calculateTransferTime(double bandwidth) {
        // Convert KB to Mb and bandwidth from Mbps to KBps
        double transferSize = networkDemand;
        double bandwidthKBps = bandwidth * 125; // 1 Mbps = 125 KBps
        return (transferSize / bandwidthKBps) * 1000; // Convert to milliseconds
    }
    
    /**
     * Calculate the total service time (transfer + execution)
     * @param bandwidth Available bandwidth in Mbps
     * @param mips Million Instructions Per Second of the executing resource
     * @return Total service time in milliseconds
     */
    public double calculateServiceTime(double bandwidth, double mips) {
        return calculateTransferTime(bandwidth) + calculateExecutionTime(mips);
    }
    
    /**
     * Mark the task as started
     */
    public void markStarted() {
        this.startTime = System.currentTimeMillis();
        this.status = TaskStatus.EXECUTING;
    }
    
    /**
     * Mark the task as completed
     */
    public void markCompleted() {
        this.completionTime = System.currentTimeMillis();
        this.status = TaskStatus.COMPLETED;
        
        // Generate some sample data as task output
        generateResultData();
    }
    
    /**
     * Mark the task as failed
     */
    public void markFailed() {
        this.completionTime = System.currentTimeMillis();
        this.status = TaskStatus.FAILED;
    }
    
    /**
     * Generate sample result data from task execution
     */
    private void generateResultData() {
        // Only generate data for completed tasks
        if (status != TaskStatus.COMPLETED) {
            return;
        }
        
        // Generate different types of data based on execution location
        Map<String, Object> data = new HashMap<>();
        data.put("taskId", taskId);
        data.put("executionTime", getActualExecutionTime());
        data.put("timestamp", System.currentTimeMillis());
        data.put("sourceDevice", sourceDeviceId);
        
        // Add some random metrics based on task type (derived from CPU demand)
        if (cpuDemand < 5000) { // Low CPU task - sensor data
            data.put("dataType", "sensor_reading");
            data.put("temperature", 20 + Math.random() * 10);
            data.put("humidity", 30 + Math.random() * 50);
            data.put("pressure", 1000 + Math.random() * 50);
        } else if (cpuDemand < 10000) { // Medium CPU task - analytics result
            data.put("dataType", "analytics_result");
            data.put("anomalyDetected", Math.random() > 0.8);
            data.put("confidenceScore", 0.7 + Math.random() * 0.3);
            data.put("predictionValue", Math.random() * 100);
        } else { // High CPU task - processed media
            data.put("dataType", "processed_media");
            data.put("processingType", "image_recognition");
            data.put("objectsDetected", (int)(1 + Math.random() * 10));
            data.put("processingQuality", "high");
        }
        
        this.generatedData = data;
        this.hasGeneratedData = true;
    }
    
    /**
     * Apply encryption to the task data
     * @param secureCommunication The secure communication service to use
     * @return True if encryption was successful
     */
    public boolean encrypt(SecureCommunication secureCommunication) {
        if (isEncrypted) {
            return true; // Already encrypted
        }
        
        try {
            // Generate a unique encryption ID for this task
            String encryptionId = UUID.randomUUID().toString();
            securityMetadata.put("encryptionId", encryptionId);
            
            // In a real implementation, we would encrypt the actual task data here
            // For simulation, we just mark it as encrypted
            isEncrypted = true;
            return true;
        } catch (Exception e) {
            System.err.println("Failed to encrypt task: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Decrypt the task data
     * @param secureCommunication The secure communication service to use
     * @return True if decryption was successful
     */
    public boolean decrypt(SecureCommunication secureCommunication) {
        if (!isEncrypted) {
            return true; // Not encrypted
        }
        
        try {
            // In a real implementation, we would decrypt the actual task data here
            // For simulation, we just mark it as decrypted
            isEncrypted = false;
            return true;
        } catch (Exception e) {
            System.err.println("Failed to decrypt task: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Verify the integrity of the task using its hash
     * @return True if integrity check passes
     */
    public boolean verifyIntegrity() {
        if (integrityHash == null) {
            return true; // No integrity protection
        }
        
        // Recalculate hash and compare
        String calculatedHash = SecureCommunication.generateHash(
            taskId + sourceDeviceId + cpuDemand + networkDemand);
        return integrityHash.equals(calculatedHash);
    }
    
    /**
     * Check if the task has security metadata
     * @return True if the task has security metadata
     */
    public boolean hasSecurityMetadata() {
        return securityToken != null && integrityHash != null;
    }
    
    /**
     * Check if the task has generated data
     * @return True if the task has generated data
     */
    public boolean hasGeneratedData() {
        return hasGeneratedData;
    }
    
    /**
     * Get the data generated by this task
     * @return Map containing the generated data
     */
    public Map<String, Object> getGeneratedData() {
        return generatedData;
    }
    
    /**
     * Calculate the actual service time based on timestamps
     * @return Actual service time in milliseconds
     */
    public long getActualServiceTime() {
        if (status != TaskStatus.COMPLETED) {
            return -1; // Task not completed yet
        }
        return completionTime - creationTime;
    }
    
    /**
     * Calculate the actual execution time based on timestamps
     * @return Actual execution time in milliseconds
     */
    public long getActualExecutionTime() {
        if (status != TaskStatus.COMPLETED) {
            return -1; // Task not completed yet
        }
        return completionTime - startTime;
    }
    
    // Getters and setters
    public String getTaskId() {
        return taskId;
    }
    
    public int getSourceDeviceId() {
        return sourceDeviceId;
    }
    
    public double getCpuDemand() {
        return cpuDemand;
    }
    
    public double getNetworkDemand() {
        return networkDemand;
    }
    
    public double getDelaySensitivity() {
        return delaySensitivity;
    }
    
    public long getCreationTime() {
        return creationTime;
    }
    
    public TaskStatus getStatus() {
        return status;
    }
    
    public void setStatus(TaskStatus status) {
        this.status = status;
    }
    
    public String getExecutionLocation() {
        return executionLocation;
    }
    
    public void setExecutionLocation(String executionLocation) {
        this.executionLocation = executionLocation;
    }
    
    public String getSecurityToken() {
        return securityToken;
    }
    
    /**
     * Set the security token for this task
     * @param token Security token to set
     */
    public void setSecurityToken(String token) {
        this.securityToken = token;
    }
    
    public Map<String, Object> getSecurityMetadata() {
        return securityMetadata;
    }
    
    /**
     * Add metadata to the task's security metadata
     * @param key Metadata key
     * @param value Metadata value
     */
    public void addMetadata(String key, Object value) {
        if (this.securityMetadata == null) {
            this.securityMetadata = new HashMap<>();
        }
        this.securityMetadata.put(key, value);
    }
    
    public boolean isEncrypted() {
        return isEncrypted;
    }
    
    /**
     * Get the task ID
     * @return Task ID
     */
    public String getId() {
        return taskId;
    }
    
    /**
     * Get the task type (derived from CPU demand)
     * @return Task type as a string
     */
    public String getType() {
        if (cpuDemand < 5000) {
            return "LIGHT";
        } else if (cpuDemand < 10000) {
            return "MEDIUM";
        } else {
            return "HEAVY";
        }
    }
    
    /**
     * Get the task size (network demand in KB)
     * @return Task size
     */
    public double getSize() {
        return networkDemand;
    }
    
    /**
     * Get the task deadline (derived from delay sensitivity)
     * @return Task deadline in milliseconds from creation time
     */
    public long getDeadline() {
        // Calculate deadline based on delay sensitivity
        // Higher sensitivity = shorter deadline
        if (delaySensitivity > 0.8) {
            return creationTime + 5000; // 5 seconds
        } else if (delaySensitivity > 0.5) {
            return creationTime + 10000; // 10 seconds
        } else {
            return creationTime + 30000; // 30 seconds
        }
    }
    
    @Override
    public String toString() {
        return "Task{" +
                "taskId='" + taskId + '\'' +
                ", cpuDemand=" + cpuDemand +
                ", networkDemand=" + networkDemand +
                ", delaySensitivity=" + delaySensitivity +
                ", status=" + status +
                ", executionLocation='" + executionLocation + '\'' +
                '}';
    }
}
